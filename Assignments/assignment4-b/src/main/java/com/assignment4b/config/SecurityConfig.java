package com.assignment4b.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AbstractAuthenticationToken;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.oauth2.jwt.*;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationToken;
import org.springframework.security.web.SecurityFilterChain;

import com.assignment4b.controller.AuthController;

import java.util.Collection;
import java.util.List;
import java.util.stream.Collectors;
import javax.crypto.SecretKey; // Required for type casting the key

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    private final AuthController
    authController;

    public SecurityConfig(AuthController authController) {
        this.authController = authController;
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.csrf(csrf -> csrf.disable()) // Disable CSRF for Stateless API (JWT)
            
            // 1. Authorization Rules (Order Matters: PermitAll first!)
            .authorizeHttpRequests(auth -> auth
                // Allow public access for Swagger UI, API docs, and JWT login/token generation
                .requestMatchers("/swagger-ui/**", "/v3/api-docs/**", "/api/auth/**").permitAll() 
                
                // Require authentication for /hello to trigger the OAuth2 login flow
                .requestMatchers("/hello").authenticated() 
                
                // Require ADMIN role for admin endpoints (JWT-protected)
                .requestMatchers("/api/admin/**").hasRole("ADMIN") 
                
                // All other requests require authentication (will be caught by either OAuth2 Login or JWT)
                .anyRequest().authenticated() 
            )

            // 2. Enable Session-based Login (Google OAuth2 Client)
            // This is primarily used for browser access to endpoints like /hello
            .oauth2Login(); 
            
            // 3. Enable Token-based Authentication (JWT Resource Server)
            // This is primarily used for API calls to endpoints like /api/secure
            http.oauth2ResourceServer(oauth2 -> oauth2.jwt(jwt -> 
                jwt.jwtAuthenticationConverter(this::convertJwt)));

        return http.build();
    }

    /**
     * Configures the JwtDecoder to use the secret key generated by the AuthController
     */
    @Bean
    public JwtDecoder jwtDecoder() { 
        return NimbusJwtDecoder.withSecretKey((SecretKey) authController.getKey()).build();
    }

    /**
     * Customizes the JWT authentication process to extract the 'roles' claim
     * and map them to Spring Security authorities.
     */
    private AbstractAuthenticationToken convertJwt(Jwt jwt) {
        // Extracts 'roles' claim (which is a List<String>) and maps them to SimpleGrantedAuthority
        Collection<GrantedAuthority> authorities = ((List<String>)
                jwt.getClaims().get("roles")).stream() 
                .map(SimpleGrantedAuthority::new)
                .collect(Collectors.toList());

        return new JwtAuthenticationToken(jwt, authorities); 
    }
}